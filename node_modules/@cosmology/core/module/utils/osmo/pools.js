import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

import Long from 'long';
import { Dec } from '@keplr-wallet/unit';
import { getOsmoAssetByDenom, makePoolsPretty } from './utils';
import { getPricesFromCoinGecko, prettyPool } from '../../clients';
export const makePoolPairs = (pools, liquidityLimit = 100000) => {
  return pools.filter(Boolean).filter(pool => new Dec(pool.liquidity).gte(new Dec(liquidityLimit))).filter(pool => pool.tokens.length === 2) // only pairs
  .map(pool => {
    const assetA = pool.tokens[0];
    const assetAinfo = getOsmoAssetByDenom(assetA.denom);
    const assetB = pool.tokens[1];
    const assetBinfo = getOsmoAssetByDenom(assetB.denom);
    return _objectSpread(_objectSpread({}, pool), {}, {
      pool_address: pool.address,
      base_name: assetAinfo.display,
      base_symbol: assetAinfo.symbol,
      base_address: assetAinfo.base,
      quote_name: assetBinfo.display,
      quote_symbol: assetBinfo.symbol,
      quote_address: assetBinfo.base
    });
  });
};
export const getPoolsDecoded = async client => {
  const rpcPools = await client.osmosis.gamm.v1beta1.pools({
    pagination: {
      key: new Uint8Array(),
      offset: Long.fromNumber(0),
      limit: Long.fromNumber(1500),
      countTotal: false,
      reverse: false
    }
  });
  return rpcPools.pools.filter(pool => [// '/osmosis.gamm.poolmodels.stableswap.v1beta1.Pool',
  '/osmosis.gamm.v1beta1.Pool'].includes(pool.$typeUrl));
};
export const getBalancerPools = async client => {
  const rawPools = await getPoolsDecoded(client);
  const pools = rawPools.map(pool => prettyPool(pool));
  return pools;
};
export const getPoolsPricesPairs = async client => {
  const pools = await getBalancerPools(client);
  const prices = await getPricesFromCoinGecko();
  const prettyPools = makePoolsPretty(prices, pools);
  const pairs = makePoolPairs(prettyPools);
  return {
    pools,
    prices,
    pairs,
    prettyPools
  };
};