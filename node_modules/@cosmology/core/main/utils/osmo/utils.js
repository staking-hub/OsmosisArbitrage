"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.symbolsAndDisplayValuesToCoinsArray = exports.symbolToOsmoDenom = exports.substractCoins = exports.routeThroughPool = exports.poolAllocationToCoinsNeeded = exports.osmoDenomToSymbol = exports.makePoolsPrettyValues = exports.makePoolsPretty = exports.makeLcdPoolPretty = exports.lookupRoutesForTrade = exports.getUserPools = exports.getTradesRequiredToGetBalances = exports.getSymbolForCoinGeckoId = exports.getSwaps = exports.getSellableBalanceTelescopeVersion = exports.getSellableBalance = exports.getPoolInfo = exports.getPoolByGammName = exports.getOsmoAssetByDenom = exports.getFilteredPoolsWithValues = exports.getCoinGeckoIdForSymbol = exports.convertWeightsIntoCoins = exports.convertValidatorPricesToDenomPriceHash = exports.convertPoolsToDisplayValues = exports.convertPoolToDisplayValues = exports.convertGeckoPricesToDenomPriceHash = exports.convertCoinsToDisplayValues = exports.convertCoinValueToCoin = exports.convertCoinToDisplayValues = exports.canonicalizeCoinWeights = exports.calculateShareOutAmount = exports.calculateMaxCoinsForPool = exports.calculateCoinsTotalBalance = exports.calculateCoinsNeededInPoolForValue = exports.calculateAmountWithSlippage = exports.addCoins = exports.OsmosisToken = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _assets = require("../../assets");

var _chain = require("../chain");

var _unit = require("@keplr-wallet/unit");

var _messages = require("../../messages");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var getCoinGeckoIdForSymbol = function getCoinGeckoIdForSymbol(token) {
  var rec = _assets.assets.find(function (_ref) {
    var symbol = _ref.symbol;
    return symbol === token;
  });

  var geckoId = rec === null || rec === void 0 ? void 0 : rec.coingecko_id;

  if (!geckoId) {
    return console.log("cannot find coin: ".concat(token));
  }

  return geckoId;
};
/**
 * @param {CoinGeckoToken} geckoId
 * @returns {CoinSymbol}
 */


exports.getCoinGeckoIdForSymbol = getCoinGeckoIdForSymbol;

var getSymbolForCoinGeckoId = function getSymbolForCoinGeckoId(geckoId) {
  var rec = _assets.assets.find(function (_ref2) {
    var coingecko_id = _ref2.coingecko_id;
    return coingecko_id === geckoId;
  });

  var symbol = rec === null || rec === void 0 ? void 0 : rec.symbol; // if (!symbol) {
  // console.log(`WARNING: cannot find coin for geckoId: ${geckoId}`);
  // }

  return symbol;
};

exports.getSymbolForCoinGeckoId = getSymbolForCoinGeckoId;

var osmoDenomToSymbol = function osmoDenomToSymbol(denom) {
  var rec = _assets.assets.find(function (_ref3) {
    var base = _ref3.base;
    return base === denom;
  });

  var symbol = rec === null || rec === void 0 ? void 0 : rec.symbol;

  if (!symbol) {
    return denom;
  }

  return symbol;
};

exports.osmoDenomToSymbol = osmoDenomToSymbol;

var getOsmoAssetByDenom = function getOsmoAssetByDenom(denom) {
  return _assets.assets.find(function (asset) {
    return asset.base === denom;
  });
};

exports.getOsmoAssetByDenom = getOsmoAssetByDenom;

var symbolToOsmoDenom = function symbolToOsmoDenom(token) {
  var rec = _assets.assets.find(function (_ref4) {
    var symbol = _ref4.symbol;
    return symbol === token;
  });

  var base = rec === null || rec === void 0 ? void 0 : rec.base;

  if (!base) {
    console.log("cannot find base for token ".concat(token));
    return null;
  }

  return base;
};

exports.symbolToOsmoDenom = symbolToOsmoDenom;

var OsmosisToken = /*#__PURE__*/function () {
  function OsmosisToken(_ref5) {
    var symbol = _ref5.symbol,
        denom = _ref5.denom,
        _ref5$amount = _ref5.amount,
        amount = _ref5$amount === void 0 ? '0' : _ref5$amount;
    (0, _classCallCheck2["default"])(this, OsmosisToken);
    (0, _defineProperty2["default"])(this, "symbol", void 0);
    (0, _defineProperty2["default"])(this, "denom", void 0);
    (0, _defineProperty2["default"])(this, "amount", void 0);

    if (symbol) {
      this.symbol = symbol;
      this.denom = symbolToOsmoDenom(symbol);
    }

    if (denom) {
      this.denom = denom;
      this.symbol = osmoDenomToSymbol(denom);
    }

    this.amount = (0, _chain.displayUnitsToDenomUnits)(this.symbol, amount);
  }
  /**
   * @returns {Coin}
   */


  (0, _createClass2["default"])(OsmosisToken, [{
    key: "toJSON",
    value: function toJSON() {
      return {
        denom: this.denom,
        amount: this.amount
      };
    }
  }]);
  return OsmosisToken;
}();

exports.OsmosisToken = OsmosisToken;

var symbolsAndDisplayValuesToCoinsArray = function symbolsAndDisplayValuesToCoinsArray(coins) {
  return coins.map(function (_ref6) {
    var symbol = _ref6.symbol,
        amount = _ref6.amount;
    return {
      denom: symbolToOsmoDenom(symbol),
      amount: (0, _chain.displayUnitsToDenomUnits)(symbol, amount)
    };
  });
};

exports.symbolsAndDisplayValuesToCoinsArray = symbolsAndDisplayValuesToCoinsArray;

var substractCoins = function substractCoins(balances1, balances2) {
  return balances1.reduce(function (m, coin) {
    var newCoin = _objectSpread({}, coin); // due to swaps and how we use this method,
    // balances2 can have multiple versions of the same symbol
    // so just subtract all of them...


    var coins = balances2.filter(function (_ref7) {
      var denom = _ref7.denom;
      return denom == coin.denom;
    });
    coins.forEach(function (c2) {
      var a = new _unit.Dec(newCoin.amount);
      var b = new _unit.Dec(c2.amount);
      newCoin.amount = a.sub(b).toString();

      if (coin.hasOwnProperty('displayAmount') && c2.hasOwnProperty('displayAmount')) {
        var _a = new _unit.Dec(newCoin.displayAmount);

        var _b = new _unit.Dec(c2.displayAmount);

        newCoin.displayAmount = _a.sub(_b).toString();
      }

      if (coin.hasOwnProperty('value') && c2.hasOwnProperty('value')) {
        var _a2 = new _unit.Dec(newCoin.value);

        var _b2 = new _unit.Dec(c2.value);

        newCoin.value = _a2.sub(_b2).toString();
      }
    });
    return [].concat((0, _toConsumableArray2["default"])(m), [newCoin]);
  }, []);
};

exports.substractCoins = substractCoins;

var addCoins = function addCoins(balances1, balances2) {
  return balances1.reduce(function (m, coin) {
    var newCoin = _objectSpread({}, coin);

    var coins = balances2.filter(function (_ref8) {
      var denom = _ref8.denom;
      return denom == coin.denom;
    });
    coins.forEach(function (c2) {
      var a = new _unit.Dec(newCoin.amount);
      var b = new _unit.Dec(c2.amount);
      newCoin.amount = a.add(b).toString();

      if (coin.hasOwnProperty('displayAmount') && c2.hasOwnProperty('displayAmount')) {
        var _a3 = new _unit.Dec(newCoin.displayAmount);

        var _b3 = new _unit.Dec(c2.displayAmount);

        newCoin.displayAmount = _a3.add(_b3).toString();
      }

      if (coin.hasOwnProperty('value') && c2.hasOwnProperty('value')) {
        var _a4 = new _unit.Dec(newCoin.value);

        var _b4 = new _unit.Dec(c2.value);

        newCoin.value = _a4.add(_b4).toString();
      }
    });
    return [].concat((0, _toConsumableArray2["default"])(m), [newCoin]);
  }, []);
};

exports.addCoins = addCoins;

var convertCoinValueToCoin = function convertCoinValueToCoin(_ref9) {
  var prices = _ref9.prices,
      denom = _ref9.denom,
      value = _ref9.value;
  var price = prices[denom];
  var symbol = osmoDenomToSymbol(denom);

  if (isNaN(price)) {
    // console.log(`bad price for ${denom} NaN.`);
    return null;
  }

  var v = new _unit.Dec(value);
  var p = new _unit.Dec(prices[denom]);
  var displayAmount = v.quo(p).toString();
  return {
    symbol: symbol,
    denom: denom,
    amount: (0, _chain.displayUnitsToDenomUnits)(symbol, displayAmount),
    displayAmount: displayAmount,
    value: new _unit.Dec(value).toString()
  };
};

exports.convertCoinValueToCoin = convertCoinValueToCoin;

var convertCoinToDisplayValues = function convertCoinToDisplayValues(_ref10) {
  var prices = _ref10.prices,
      coin = _ref10.coin;
  var denom = coin.denom,
      amount = coin.amount;
  var price = prices[denom];
  var symbol = osmoDenomToSymbol(denom);

  if (isNaN(price)) {
    // console.log(`bad price for ${denom} NaN.`);
    return null;
  }

  var displayAmount = (0, _chain.baseUnitsToDisplayUnits)(symbol, amount); // if (isNaN(displayAmount)) {
  //   // console.log('bad amount, NaN.');
  //   return null;
  // }

  var dA = new _unit.Dec(displayAmount);
  var assetPrice = new _unit.Dec(prices[denom]);
  var value = dA.mul(assetPrice).toString();
  return {
    symbol: symbol,
    denom: denom,
    amount: amount,
    displayAmount: displayAmount,
    value: value
  };
};

exports.convertCoinToDisplayValues = convertCoinToDisplayValues;

var convertCoinsToDisplayValues = function convertCoinsToDisplayValues(_ref11) {
  var prices = _ref11.prices,
      coins = _ref11.coins;
  return coins.map(function (coin) {
    return convertCoinToDisplayValues({
      prices: prices,
      coin: coin
    });
  }).filter(Boolean);
};

exports.convertCoinsToDisplayValues = convertCoinsToDisplayValues;

var calculateCoinsTotalBalance = function calculateCoinsTotalBalance(_ref12) {
  var prices = _ref12.prices,
      coins = _ref12.coins;
  return convertCoinsToDisplayValues({
    prices: prices,
    coins: coins
  }).reduce(function (m, v) {
    try {
      var value = v.value;
      var val = new _unit.Dec(value);
      var mv = new _unit.Dec(m);
      return val.add(mv).toString();
    } catch (e) {
      return m;
    }
  }, '0');
};

exports.calculateCoinsTotalBalance = calculateCoinsTotalBalance;

var convertGeckoPricesToDenomPriceHash = function convertGeckoPricesToDenomPriceHash(prices) {
  return Object.keys(prices).reduce(function (m, geckoId) {
    var symbol = getSymbolForCoinGeckoId(geckoId);

    if (symbol) {
      var denom = symbolToOsmoDenom(symbol);
      m[denom] = prices[geckoId].usd;
    }

    return m;
  }, {});
};

exports.convertGeckoPricesToDenomPriceHash = convertGeckoPricesToDenomPriceHash;

var convertValidatorPricesToDenomPriceHash = function convertValidatorPricesToDenomPriceHash(tokens) {
  return tokens.reduce(function (m, token) {
    m[token.denom] = token.price;
    return m;
  }, {});
};

exports.convertValidatorPricesToDenomPriceHash = convertValidatorPricesToDenomPriceHash;

var getPoolByGammName = function getPoolByGammName(pools, gammId) {
  return pools.find(function (_ref13) {
    var denom = _ref13.totalShares.denom;
    return denom === gammId;
  });
};

exports.getPoolByGammName = getPoolByGammName;

var getPoolInfo = function getPoolInfo(_ref14) {
  var prices = _ref14.prices,
      pools = _ref14.pools,
      poolId = _ref14.poolId;
  var pool = pools.find(function (_ref15) {
    var id = _ref15.id;
    return id === poolId;
  });
  if (!pool) throw new Error('cannot find pool');
  return convertPoolToDisplayValues({
    prices: prices,
    pool: pool
  });
};

exports.getPoolInfo = getPoolInfo;

var getUserPools = function getUserPools(_ref16) {
  var pools = _ref16.pools,
      lockedPools = _ref16.lockedPools;
  return lockedPools.map(function (_ref17) {
    var denom = _ref17.denom,
        amount = _ref17.amount;
    var pool = getPoolByGammName(pools, denom); // TODO why some pools missing?

    if (!pool) return null;
    var p = new _unit.Dec(pool.pricePerShareEn18);
    var a = new _unit.Dec(amount);
    var ta = new _unit.Dec(pool.totalShares.amount);
    var value = new _unit.IntPretty(p.mul(a)).moveDecimalPointLeft(18).maxDecimals(18).locale(false).toString();
    var allocation = a.quo(ta).toString();
    return {
      denom: denom,
      amount: amount,
      value: value,
      allocation: allocation,
      poolId: pool.id
    };
  }).filter(Boolean);
};

exports.getUserPools = getUserPools;

var convertPoolToDisplayValues = function convertPoolToDisplayValues(_ref18) {
  var prices = _ref18.prices,
      pool = _ref18.pool;
  var totalShares = pool.totalShares,
      poolAssets = pool.poolAssets;

  var enrichedPool = _objectSpread({}, pool);

  var totalValue = new _unit.Dec(0);
  enrichedPool.displayPoolAssets = poolAssets.map(function (_ref19) {
    var token = _ref19.token,
        weight = _ref19.weight;
    var value = convertCoinToDisplayValues({
      prices: prices,
      coin: token
    });
    if (!value) return undefined;
    var val = new _unit.Dec(value.value);
    totalValue = totalValue.add(val);
    var w = new _unit.Dec(weight);
    var wt = new _unit.Dec(pool.totalWeight);
    return {
      token: token,
      weight: weight,
      allocation: w.quo(wt).toString(),
      symbol: osmoDenomToSymbol(token.denom),
      value: value
    };
  }).filter(Boolean);
  enrichedPool.totalValue = totalValue.toString();
  var ta = new _unit.Dec(totalShares.amount);
  var totalSharesAmount = new _unit.IntPretty(ta);
  var totalVal = new _unit.IntPretty(totalValue);

  if (ta.lte(new _unit.Dec(0))) {
    enrichedPool.pricePerShareEn18 = '0';
  } else {
    enrichedPool.pricePerShareEn18 = totalVal.maxDecimals(18).quo(totalSharesAmount.moveDecimalPointLeft(18).maxDecimals(18)) // .moveDecimalPointLeft(18)
    .locale(false).toString();
  }

  enrichedPool.name = enrichedPool.displayPoolAssets.reduce(function (m, v) {
    return [].concat((0, _toConsumableArray2["default"])(m), [v.symbol]);
  }, []).join('/');
  return enrichedPool;
};

exports.convertPoolToDisplayValues = convertPoolToDisplayValues;

var convertPoolsToDisplayValues = function convertPoolsToDisplayValues(_ref20) {
  var prices = _ref20.prices,
      pools = _ref20.pools;
  return pools.map(function (pool) {
    return convertPoolToDisplayValues({
      prices: prices,
      pool: pool
    });
  });
};

exports.convertPoolsToDisplayValues = convertPoolsToDisplayValues;

var getFilteredPoolsWithValues = function getFilteredPoolsWithValues(_ref21) {
  var prices = _ref21.prices,
      pools = _ref21.pools;
  return convertPoolsToDisplayValues({
    prices: prices,
    pools: pools
  });
}; // remove small pools
// .filter(({ totalValue }) => totalValue >= 100000)
// remove DIG or VIDL or coins not on coingecko that don't get prices
// .filter(({ poolAssets, displayPoolAssets }) => poolAssets.length === displayPoolAssets.length);


exports.getFilteredPoolsWithValues = getFilteredPoolsWithValues;

var getTradesRequiredToGetBalances = function getTradesRequiredToGetBalances(_ref22) {
  var prices = _ref22.prices,
      balances = _ref22.balances,
      desired = _ref22.desired;
  var totalCurrent = calculateCoinsTotalBalance({
    prices: prices,
    coins: balances
  });
  var totalDesired = calculateCoinsTotalBalance({
    prices: prices,
    coins: desired
  });
  var t = new _unit.Dec(totalDesired);
  var c = new _unit.Dec(totalCurrent);

  if (t.gt(c) && !t.sub(c).lte(new _unit.Dec(0.01))) {
    // if t > c, but the difference IS not a small number
    console.log(t.toString(), c.toString());
    throw new Error('insufficient balance');
  }

  var hasEnough = desired.reduce(function (m, _ref23) {
    var denom = _ref23.denom,
        amount = _ref23.amount;
    var current = balances.find(function (c) {
      return c.denom === denom;
    });
    if (!current) return false;
    var a = new _unit.Dec(current.amount);
    var b = new _unit.Dec(amount);
    if (a.gte(b)) return m && true;
    return false;
  }, true);

  if (hasEnough) {
    // no trades are required
    return [];
  }

  var currentCoins = convertCoinsToDisplayValues({
    prices: prices,
    coins: balances
  });
  var desiredCoins = convertCoinsToDisplayValues({
    prices: prices,
    coins: desired
  }); // returns a list of the available coins

  var availableCoins = balances.reduce(function (m, coin) {
    var denom = coin.denom;
    var desiredCoin = desiredCoins.find(function (c) {
      return c.denom === denom;
    });

    if (!desiredCoin) {
      return [].concat((0, _toConsumableArray2["default"])(m), [coin]);
    }

    var a = new _unit.Dec(coin.amount);
    var b = new _unit.Dec(desiredCoin.amount);
    var diff = a.sub(b);

    if (diff.lte(new _unit.Dec(0))) {
      return m;
    }

    return [].concat((0, _toConsumableArray2["default"])(m), [{
      denom: coin.denom,
      amount: diff.toString()
    }]);
  }, []); // coins needed

  var desiredCoinsNeeded = desired.reduce(function (m, coin) {
    var denom = coin.denom;
    var current = currentCoins.find(function (c) {
      return c.denom === denom;
    });

    if (!current) {
      return [].concat((0, _toConsumableArray2["default"])(m), [coin]);
    }

    var a = new _unit.Dec(coin.amount);
    var b = new _unit.Dec(current.amount);
    var aMinusB = a.sub(b);
    var diff = {
      denom: coin.denom,
      amount: aMinusB.toString()
    };
    if (aMinusB.lte(new _unit.Dec(0))) return m;
    return [].concat((0, _toConsumableArray2["default"])(m), [diff]);
  }, []);
  var availableCoinsValue = calculateCoinsTotalBalance({
    prices: prices,
    coins: availableCoins
  });
  var desiredCoinsNeededValue = calculateCoinsTotalBalance({
    prices: prices,
    coins: desiredCoinsNeeded
  });
  var availableCoinsWithValues = convertCoinsToDisplayValues({
    prices: prices,
    coins: availableCoins
  });
  var desiredCoinsNeededWithValues = convertCoinsToDisplayValues({
    prices: prices,
    coins: desiredCoinsNeeded
  });
  var dsr = new _unit.Dec(desiredCoinsNeededValue);
  var avl = new _unit.Dec(availableCoinsValue);

  if (dsr.gt(avl) && !dsr.sub(avl).lte(new _unit.Dec(0.01))) {
    throw new Error("not possible with current values (desired[".concat(desiredCoinsNeededValue, "] > available[").concat(availableCoinsValue, "])"));
  } // trades are required


  var trades = desiredCoinsNeededWithValues.reduce(function (m, coin) {
    var valueNeeded = new _unit.Dec(coin.value);

    for (var i = 0; i < availableCoinsWithValues.length; i++) {
      if (valueNeeded.lte(new _unit.Dec(0))) continue;
      var current = availableCoinsWithValues[i];
      if (coin.symbol === current.symbol) continue;
      var currentVal = new _unit.Dec(current.value);

      if (currentVal.gte(valueNeeded)) {
        // console.log(`I desired:${coin.symbol} avail:${current.symbol}`);
        // console.log(`I valueNeeded:${valueNeeded}`);
        // 1. value is more than what is needed
        // TAKE WHAT YOU NEED
        var leftOver = currentVal.sub(valueNeeded);
        var amountUsed = new _unit.Dec(valueNeeded.toString());
        valueNeeded = valueNeeded.sub(amountUsed);
        m.push({
          sell: convertCoinValueToCoin({
            prices: prices,
            denom: current.denom,
            value: amountUsed.toString()
          }),
          buy: convertCoinValueToCoin({
            prices: prices,
            denom: coin.denom,
            value: amountUsed.toString()
          }),
          beliefValue: amountUsed.toString()
        });
        current.value = leftOver.toString();
        availableCoinsWithValues[i].value = leftOver.toString();
      } else if (currentVal.lt(valueNeeded)) {
        // console.log(`II desired:${coin.symbol} avail:${current.symbol}`);
        // console.log(`II valueNeeded:${valueNeeded}`);
        // 2. value is less than what is needed
        // TAKE IT ALL!
        var _amountUsed = new _unit.Dec(current.value);

        valueNeeded = valueNeeded.sub(_amountUsed);
        m.push({
          sell: convertCoinValueToCoin({
            prices: prices,
            denom: current.denom,
            value: _amountUsed.toString()
          }),
          buy: convertCoinValueToCoin({
            prices: prices,
            denom: coin.denom,
            value: _amountUsed.toString()
          }),
          beliefValue: _amountUsed.toString()
        });
        current.value = '0';
        availableCoinsWithValues[i].value = '0';
      }
    }

    return m;
  }, []);
  return trades;
};
/**
 * this is used to canonicalize CoinWeights so a user can
 * pass in only some properties, like poolId, or symbol, etc.,
 * and it will determine the denom, etc.
 */


exports.getTradesRequiredToGetBalances = getTradesRequiredToGetBalances;

var canonicalizeCoinWeights = function canonicalizeCoinWeights(_ref24) {
  var weights = _ref24.weights,
      pools = _ref24.pools,
      prices = _ref24.prices,
      totalCurrentValue = _ref24.totalCurrentValue;
  var totalValue = new _unit.Dec(0);
  var enriched = weights.map(function (item) {
    if (!item.weight || new _unit.Dec(item.weight).lt(new _unit.Dec(0))) throw new Error('no non-positive weights');
    var wt = new _unit.Dec(item.weight);
    totalValue = totalValue.add(wt);

    if (!item.denom) {
      if (item.symbol) {
        item.denom = symbolToOsmoDenom(item.symbol);
      }

      if (item.poolId) {
        var _pool$totalShares;

        var pool = pools.find(function (_ref25) {
          var id = _ref25.id;
          return item.poolId == id;
        });
        item.denom = pool === null || pool === void 0 ? void 0 : (_pool$totalShares = pool.totalShares) === null || _pool$totalShares === void 0 ? void 0 : _pool$totalShares.denom;
      }

      if (!item.denom) {
        throw new Error('cannot determine weight type');
      }
    }

    if (item.denom.startsWith('gamm')) {
      item.type = 'pool';

      var _pool = getPoolByGammName(pools, item.denom);

      if (!_pool) throw new Error("cannot find pool ".concat(item.denom));
      item.poolId = _pool.id;
      var info = getPoolInfo({
        prices: prices,
        pools: pools,
        poolId: item.poolId
      });
      item.name = info.name;
    } else {
      item.type = 'coin';
      item.name = osmoDenomToSymbol(item.denom);
      item.symbol = osmoDenomToSymbol(item.denom);
    }

    return item;
  });
  return enriched.map(function (item) {
    var allocation = new _unit.Dec(item.weight).quo(totalValue).toString();
    var value;

    if (typeof totalCurrentValue !== 'undefined') {
      var tcv = new _unit.Dec(totalCurrentValue);
      var wt = new _unit.Dec(item.weight);
      value = tcv.mul(wt).quo(totalValue).toString();
    }

    return _objectSpread(_objectSpread({}, item), {}, {
      allocation: allocation,
      value: value
    });
  });
};

exports.canonicalizeCoinWeights = canonicalizeCoinWeights;

var poolAllocationToCoinsNeeded = function poolAllocationToCoinsNeeded(_ref26) {
  var pools = _ref26.pools,
      prices = _ref26.prices,
      weight = _ref26.weight;

  if (weight.type !== 'pool') {
    throw new Error('not yet');
  }

  var pool = getPoolInfo({
    prices: prices,
    pools: pools,
    poolId: weight.poolId
  });
  var coins = pool.displayPoolAssets.map(function (a) {
    var value = new _unit.Dec(weight.value);
    var alloc = new _unit.Dec(a.allocation);
    return convertCoinValueToCoin({
      prices: prices,
      denom: a.token.denom,
      value: value.mul(alloc).toString()
    });
  });

  if (typeof weight.value === 'undefined') {
    throw new Error('weight.value needs to be defined');
  }

  var ta = new _unit.Dec(pool.totalShares.amount);
  var tv = new _unit.Dec(pool.totalValue);
  var wv = new _unit.Dec(weight.value);
  var allocation = {
    name: pool.name,
    denom: pool.totalShares.denom,
    amount: ta.quo(tv).mul(wv).toString(),
    // TODO determine the pool multipliers
    displayAmount: '-1',
    value: weight.value,
    coins: coins
  };
  return allocation;
};

exports.poolAllocationToCoinsNeeded = poolAllocationToCoinsNeeded;

var convertWeightsIntoCoins = function convertWeightsIntoCoins(_ref27) {
  var weights = _ref27.weights,
      pools = _ref27.pools,
      prices = _ref27.prices,
      balances = _ref27.balances;
  var totalCurrentValue = calculateCoinsTotalBalance({
    prices: prices,
    coins: balances
  });
  var cleaned = canonicalizeCoinWeights({
    weights: weights,
    pools: pools,
    prices: prices,
    totalCurrentValue: totalCurrentValue
  });
  var allocations = cleaned.filter(function (c) {
    return c.type === 'pool';
  }).map(function (pool) {
    return poolAllocationToCoinsNeeded({
      pools: pools,
      prices: prices,
      weight: pool
    });
  });
  var tcv = new _unit.Dec(totalCurrentValue);
  var objs = cleaned.map(function (item) {
    var alc = new _unit.Dec(item.allocation);
    return _objectSpread(_objectSpread({}, item), {}, {
      value: tcv.mul(alc).toString()
    });
  });
  var coins = objs.filter(function (a) {
    return a.type === 'coin';
  }).map(function (coin) {
    return convertCoinValueToCoin({
      prices: prices,
      denom: coin.denom,
      value: coin.value
    });
  });
  return {
    pools: allocations,
    coins: coins,
    weights: objs
  };
};

exports.convertWeightsIntoCoins = convertWeightsIntoCoins;

var routeThroughPool = function routeThroughPool(_ref28) {
  var denom = _ref28.denom,
      trade = _ref28.trade,
      pairs = _ref28.pairs;
  var symbol = osmoDenomToSymbol(denom);
  var sellPool = pairs.find(function (pair) {
    return pair.base_address == trade.sell.denom && pair.quote_address == denom || pair.quote_address == trade.sell.denom && pair.base_address == denom;
  });
  var buyPool = pairs.find(function (pair) {
    return pair.base_address == denom && pair.quote_address == trade.buy.denom || pair.quote_address == denom && pair.base_address == trade.buy.denom;
  });

  if (sellPool && buyPool) {
    var routes = [{
      poolId: sellPool.id,
      tokenOutDenom: denom,
      tokenOutSymbol: symbol,
      tokenInSymbol: trade.sell.symbol,
      liquidity: sellPool.liquidity
    }, {
      poolId: buyPool.id,
      tokenOutDenom: trade.buy.denom,
      tokenOutSymbol: trade.buy.symbol,
      tokenInSymbol: symbol,
      liquidity: buyPool.liquidity
    }];
    return routes;
  }
};

exports.routeThroughPool = routeThroughPool;

var lookupRoutesForTrade = function lookupRoutesForTrade(_ref29) {
  var trade = _ref29.trade,
      pairs = _ref29.pairs;
  var directPool = pairs.find(function (pair) {
    return pair.base_address == trade.sell.denom && pair.quote_address == trade.buy.denom || pair.quote_address == trade.sell.denom && pair.base_address == trade.buy.denom;
  });

  if (directPool) {
    return [{
      poolId: directPool.id,
      tokenOutDenom: trade.buy.denom,
      tokenOutSymbol: trade.buy.symbol,
      tokenInSymbol: trade.sell.symbol,
      liquidity: directPool.liquidity
    }];
  }

  var osmoRoutes = routeThroughPool({
    denom: 'uosmo',
    trade: trade,
    pairs: pairs
  });
  var atomRoutes = routeThroughPool({
    denom: 'ibc/27394FB092D2ECCD56123C74F36E4C1F926001CEADA9CA97EA622B25F41E5EB2',
    trade: trade,
    pairs: pairs
  }); // if (atomRoutes?.length && osmoRoutes?.length) {
  //     const atomLiquidity = atomRoutes.reduce((m, { liquidity }) => m + liquidity, 0);
  //     const osmoLiquidity = osmoRoutes.reduce((m, { liquidity }) => m + liquidity, 0);
  //     if (atomLiquidity < osmoLiquidity) {
  //         return atomRoutes;
  //     } else {
  //         return osmoRoutes;
  //     }
  // }

  if (atomRoutes) return atomRoutes;
  if (osmoRoutes) return osmoRoutes; // TODO add ATOM routes...

  throw new Error('no trade routes found!');
};

exports.lookupRoutesForTrade = lookupRoutesForTrade;

var getSwaps = function getSwaps(_ref30) {
  var trades = _ref30.trades,
      pairs = _ref30.pairs;
  return trades.reduce(function (m, trade) {
    // not sure why, but sometimes we get a zero amount
    if (new _unit.Dec(trade.sell.value).lte(new _unit.Dec(0.0001))) return m;
    return [].concat((0, _toConsumableArray2["default"])(m), [{
      trade: trade,
      routes: lookupRoutesForTrade({
        trade: trade,
        pairs: pairs
      })
    }]);
  }, []);
};

exports.getSwaps = getSwaps;

var calculateAmountWithSlippage = function calculateAmountWithSlippage(amount, slippage) {
  var a = new _unit.Dec(amount);
  var b = new _unit.Dec(100).sub(new _unit.Dec(slippage)).quo(new _unit.Dec(100)); // Number(amount) * ((100 - slippage) / 100);

  return a.mul(b).toString();
}; //   share out amount = (token in amount * total share) / pool asset
// const tokenInAmount = new IntPretty(new Dec(amountConfig.amount));
// totalShare / poolAsset.amount = totalShare per poolAssetAmount = total share per tokenInAmount
// tokenInAmount * (total share per tokenInAmount) = totalShare of given tokenInAmount aka shareOutAmount;
// tokenInAmount in terms of totalShare unit
// shareOutAmount / totalShare = totalShare proportion of tokenInAmount;
// totalShare proportion of tokenInAmount * otherTotalPoolAssetAmount = otherPoolAssetAmount
// const shareOutAmount = tokenInAmount.mul(totalShare).quo(poolAsset.amount);

/*

`tokenInAmount` = number of tokens of coin A
`poolAsset.amount` = total number of tokens of coin A in pool
`totalShare` = total shares of pool (with exponent = 18)

`shareOutAmount` = `tokenInAmount` * `totalShare` / `poolAsset.amount`

@dev:
Yeah I think theres two options:
Simulate the message, and subtract $SLIPPAGE_PERCENTAGE from that
Doing exactly what you did (but taking the min of that over both assets)

 */


exports.calculateAmountWithSlippage = calculateAmountWithSlippage;

var calculateShareOutAmount = function calculateShareOutAmount(poolInfo, coinsNeeded) {
  var shareOuts = [];

  for (var i = 0; i < poolInfo.poolAssets.length; i++) {
    var tokenInAmount = new _unit.IntPretty(new _unit.Dec(coinsNeeded[i].amount));
    var totalShare = new _unit.IntPretty(new _unit.Dec(poolInfo.totalShares.amount));
    var totalShareExp = totalShare.moveDecimalPointLeft(18);
    var poolAssetAmount = new _unit.IntPretty(new _unit.Dec(poolInfo.poolAssets[i].token.amount));
    var shareOutAmountObj = tokenInAmount.mul(totalShareExp).quo(poolAssetAmount);

    var _shareOutAmount = shareOutAmountObj.moveDecimalPointRight(18).trim(true).shrink(true).maxDecimals(6).locale(false).toString();

    shareOuts.push(_shareOutAmount);
  }

  var shareOutAmount = shareOuts.sort()[0];
  return shareOutAmount;
};

exports.calculateShareOutAmount = calculateShareOutAmount;

var calculateCoinsNeededInPoolForValue = function calculateCoinsNeededInPoolForValue(prices, poolInfo, value) {
  var coinsNeeded = poolInfo.poolAssetsPretty.map(function (asset) {
    var v = new _unit.Dec(value);
    var r = new _unit.Dec(asset.ratio);
    var shareTotalValue = v.mul(r).toString();
    var totalDollarValue = (0, _chain.baseUnitsToDollarValue)(prices, asset.symbol, asset.amount);
    var amount = (0, _chain.dollarValueToDenomUnits)(prices, asset.symbol, shareTotalValue);
    var a = new _unit.Dec(amount);
    var b = new _unit.Dec(asset.amount);
    return {
      symbol: asset.symbol,
      denom: asset.denom,
      amount: (0, _messages.noDecimals)(amount),
      displayAmount: (0, _chain.baseUnitsToDisplayUnits)(asset.symbol, amount),
      shareTotalValue: shareTotalValue,
      totalDollarValue: totalDollarValue,
      unitRatio: a.quo(b).toString()
    };
  });
  return coinsNeeded;
};

exports.calculateCoinsNeededInPoolForValue = calculateCoinsNeededInPoolForValue;

var coinGet = function coinGet(prices, balances, asset, pAsset) {
  // get the asset
  var coinBalance = balances.find(function (coin) {
    return coin.denom == asset.token.denom;
  });

  if (!coinBalance || !coinBalance.amount) {
    console.log(JSON.stringify({
      asset: asset,
      balances: balances
    }, null, 2));
    console.log({
      coinBalance: coinBalance
    });
    throw new Error('not enough ' + pAsset.symbol);
  }

  coinBalance.displayValue = (0, _chain.baseUnitsToDollarValue)(prices, pAsset.symbol, coinBalance.amount);
  return coinBalance;
};

var calculateMaxCoinsForPool = function calculateMaxCoinsForPool(prices, poolInfo, balances) {
  var scenarios = {};

  for (var i = 0; i < poolInfo.poolAssets.length; i++) {
    var asset = poolInfo.poolAssets[i];
    var pAsset = poolInfo.poolAssetsPretty[i]; // first solve for the first asset having the amount it currently has

    scenarios[pAsset.symbol] = []; // get the asset

    var coinBalance = coinGet(prices, balances, asset, pAsset);
    var totalDollarValueOfCoinA = (0, _chain.baseUnitsToDollarValue)(prices, pAsset.symbol, coinBalance.amount);
    var tva = new _unit.Dec(totalDollarValueOfCoinA);
    var pr = new _unit.Dec(pAsset.ratio);
    var totalDollarValue = tva.quo(pr);
    scenarios[pAsset.symbol].push({
      token: coinBalance,
      ratio: pAsset.ratio,
      symbol: pAsset.symbol,
      amount: (0, _messages.noDecimals)(coinBalance.amount),
      enoughCoinsExist: true,
      totalDollarValue: totalDollarValue.toString()
    });

    for (var j = 0; j < poolInfo.poolAssets.length; j++) {
      var jAsset = poolInfo.poolAssets[j];
      var jPAsset = poolInfo.poolAssetsPretty[j];
      if (jAsset.token.denom === asset.token.denom) continue;
      var otherBalance = coinGet(prices, balances, jAsset, jPAsset);
      var ratio = new _unit.Dec(jPAsset.ratio);
      var totalDollarValueOfCoinB = totalDollarValue.mul(ratio).toString();
      var totalCoinsBDenom = (0, _chain.dollarValueToDenomUnits)(prices, jPAsset.symbol, totalDollarValueOfCoinB);
      var other = new _unit.Dec(otherBalance.amount);
      var totalB = new _unit.Dec(totalCoinsBDenom);
      var enoughCoinsExist = other.sub(totalB).gt(new _unit.Dec(0));
      scenarios[pAsset.symbol].push({
        token: otherBalance,
        ratio: jPAsset.ratio,
        symbol: jPAsset.symbol,
        amount: (0, _messages.noDecimals)(totalCoinsBDenom),
        enoughCoinsExist: enoughCoinsExist
      });
    }
  }

  var allScenarios = Object.entries(scenarios).map(function (_ref31) {
    var _ref32 = (0, _slicedToArray2["default"])(_ref31, 2),
        key = _ref32[0],
        value = _ref32[1];

    return {
      name: key,
      coins: value
    };
  });
  var winners = allScenarios.filter(function (scenario) {
    return scenario.coins.every(function (coin) {
      return coin.enoughCoinsExist;
    });
  });

  if (!winners.length) {
    throw new Error('no scenario possible!');
  }

  var winner = winners[0];
  var coinsNeeded = poolInfo.poolAssetsPretty.map(function (asset) {
    var coin = winner.coins.find(function (coin) {
      return coin.token.denom === asset.denom;
    });
    return {
      denom: coin.token.denom,
      amount: coin.amount
    };
  });
  return coinsNeeded;
};

exports.calculateMaxCoinsForPool = calculateMaxCoinsForPool;

var getSellableBalance = /*#__PURE__*/function () {
  var _ref34 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(_ref33) {
    var client, address, sell, accountBalances;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            client = _ref33.client, address = _ref33.address, sell = _ref33.sell;
            _context.next = 3;
            return client.getBalances(address);

          case 3:
            accountBalances = _context.sent;
            return _context.abrupt("return", accountBalances.result.map(function (_ref35) {
              var denom = _ref35.denom,
                  amount = _ref35.amount;
              var symbol = osmoDenomToSymbol(denom);

              try {
                var displayAmount = (0, _chain.baseUnitsToDisplayUnits)(symbol, amount);
                if (new _unit.Dec(displayAmount).lt(new _unit.Dec(0.0001))) return;
                if (!sell.includes(symbol)) return;
                return {
                  symbol: symbol,
                  denom: denom,
                  amount: amount,
                  displayAmount: displayAmount
                };
              } catch (e) {
                // likely unknown denom
                return;
              }
            }).filter(Boolean));

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getSellableBalance(_x) {
    return _ref34.apply(this, arguments);
  };
}();

exports.getSellableBalance = getSellableBalance;

var getSellableBalanceTelescopeVersion = /*#__PURE__*/function () {
  var _ref37 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(_ref36) {
    var client, address, sell, accountBalances;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            client = _ref36.client, address = _ref36.address, sell = _ref36.sell;
            _context2.next = 3;
            return client.cosmos.bank.v1beta1.allBalances({
              address: address
            });

          case 3:
            accountBalances = _context2.sent;
            return _context2.abrupt("return", accountBalances.balances.map(function (_ref38) {
              var denom = _ref38.denom,
                  amount = _ref38.amount;
              var symbol = osmoDenomToSymbol(denom);

              try {
                var displayAmount = (0, _chain.baseUnitsToDisplayUnits)(symbol, amount);
                if (new _unit.Dec(displayAmount).lt(new _unit.Dec(0.0001))) return;
                if (!sell.includes(symbol)) return;
                return {
                  symbol: symbol,
                  denom: denom,
                  amount: amount,
                  displayAmount: displayAmount
                };
              } catch (e) {
                // likely unknown denom
                return;
              }
            }).filter(Boolean));

          case 5:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function getSellableBalanceTelescopeVersion(_x2) {
    return _ref37.apply(this, arguments);
  };
}();

exports.getSellableBalanceTelescopeVersion = getSellableBalanceTelescopeVersion;

var makeLcdPoolPretty = function makeLcdPoolPretty(prices, pool) {
  var tokens = pool.poolAssets.map(function (asset) {
    var denom = asset.token.denom;
    var amount = asset.token.amount;
    var symbol = osmoDenomToSymbol(denom) || denom;
    var price = prices[asset.token.denom] || 0;

    if (!price && !prices.hasOwnProperty(asset.token.denom)) {
      return null;
    }

    var value;

    try {
      value = (0, _chain.baseUnitsToDollarValueByDenom)(prices, denom, amount);
    } catch (e) {
      value = '0.0';
    }

    return {
      price: price,
      weight: asset.weight,
      denom: denom,
      symbol: symbol,
      amount: amount,
      ratio: new _unit.Dec(asset.weight).quo(new _unit.Dec(pool.totalWeight)).toString(),
      value: value
    };
  }).filter(Boolean);
  var liquidity = tokens.reduce(function (m, v) {
    return m.add(new _unit.Dec(v.value));
  }, new _unit.Dec('0')).toString();
  var nickname = tokens.reduce(function (m, v) {
    return [].concat((0, _toConsumableArray2["default"])(m), [v.symbol]);
  }, []).join('/');
  return {
    id: pool.id,
    address: pool.address,
    denom: "gamm/pool/".concat(pool.id),
    nickname: nickname,
    liquidity: liquidity,
    tokens: tokens
  };
};

exports.makeLcdPoolPretty = makeLcdPoolPretty;

var makePoolsPrettyValues = function makePoolsPrettyValues(pools) {
  var liquidityLimit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100000;
  return pools.map(function (pool) {
    if (new _unit.Dec(pool.liquidity).gt(new _unit.Dec(liquidityLimit))) {
      return {
        name: pool.nickname,
        value: pool.id
      };
    }
  }).filter(Boolean);
};

exports.makePoolsPrettyValues = makePoolsPrettyValues;

var makePoolsPretty = function makePoolsPretty(prices, pools) {
  return pools // filter bc some some coins can be null if unsupported
  .map(function (pool) {
    return makeLcdPoolPretty(prices, pool);
  }).filter(Boolean);
};

exports.makePoolsPretty = makePoolsPretty;